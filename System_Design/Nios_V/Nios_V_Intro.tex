\documentclass[11pt, twoside, pdftex]{article}

% This include all the settings that we should use for the document
\newcommand{\PDFTitle}{Introduction to Nios\textsuperscript{\textregistered} V}
\newcommand{\commonPath}{../../Common}
\input{\commonPath/Docs/defaulttext.tex}
\input{\commonPath/Docs/preamble.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%
% Add title
\newcommand{\doctitle}{Introduction to Nios\textsuperscript{\textregistered} V}
\newcommand{\dochead}{Introduction to Nios\textsuperscript{\textregistered} V}
% Usually no need to change these two lines
\title{\fontfamily{phv}\selectfont{\doctitle} }
\chead{ \small{\textsc{\bfseries \dochead} } }
% Customizations
\newenvironment{ctabbing}%
{\begin{center}\begin{minipage}{\textwidth}\begin{tabbing}}
{\end{tabbing}\end{minipage}\end{center}}

%%%%%%%%%%%%%%%%%%%%%%%%%
% Allows multiple figures per page

\renewcommand\floatpagefraction{.9}
\renewcommand\topfraction{.9}
\renewcommand\bottomfraction{.9}
\renewcommand\textfraction{.1}   
\setcounter{totalnumber}{50}
\setcounter{topnumber}{50}
\setcounter{bottomnumber}{50}
\raggedbottom

%%%%%%%%%%%%%%%%%%
%%% DOCUMENT START
%\begin{document}
\begin{document}
\begin{table}
    \centering
    \begin{tabular}{p{5cm}p{4cm}}
        \hspace{-3cm}
        &
        \raisebox{1\height}{\parbox[h]{0.5\textwidth}{\Large\fontfamily{phv}\selectfont{\textsf{\doctitle}}}}
    \end{tabular}
    \label{tab:logo}
\end{table}

\colorbox[rgb]{0,0.384,0.816}{\parbox[h]{\textwidth}{\color{white}\textsf{\textit{\textBar}}}}

\thispagestyle{plain}
 
\section{Introduction}

This tutorial presents an introduction to the Altera\textsuperscript{\textregistered}
{\it Nios}\textsuperscript{\textregistered} {\it V} processor, 
which is an implementation of the RISC-V processor architecture. Three versions of 
Nios~V exist, each with different features and capabilities.  Documentation for each 
of the three versions, designated as {\it compact} (Nios~V/c), {\it microcontroller} (Nios~V/m),
and {\it general purpose} (Nios~V/g), can be found by searching on the Internet for keywords 
such as \texttt{Nios~V versions}.

This document is intended for a reader who is using a computer system with Nios~V on one of 
the DE-series boards that are described in the \texttt{Teaching and Projects Boards} 
section of the {\small \href{https://www.fpgacademy.org/boards.html} {FPGAcademy.org}} website. 
Thus, we focus on versions of the processor that are included in those computer
systems, which are Nios~V/m or Nios~V/g. 

{\bf Contents}:
\begin{itemize}
\item Nios~V System
\item Overview of Nios~V Processor Features
\item Register Structure
\item Accessing Memory and I/O Devices
\item Addressing
\item Instruction Set
\item Assembler Directives
\item Example Program
\item Nios~V Machine Timer and Software Interrupt Registers
\item Exception and Interrupt Processing
\end{itemize}
\clearpage
\newpage

\section{Background}

Nios~V is a soft processor, defined in a hardware description language,
which can be implemented in an Altera FPGA devices by using the 
Quartus Prime CAD system. 
In this tutorial we assume that the reader is using Nios~V as part of a computer system
that is implemented on a DE1-SoC board. If another DE-series board is used, then most of
the discussion will still be applicable, but some features of the computer system might 
be different.

\section{Nios~V System}
The Nios~V processor can be used with a variety of other components to form 
a computer system. One example of such a system is shown in Figure~\ref{fig:system}.
It is called the {\it DE1-SoC Computer with Nios~V}, and is implemented on a DE1-SoC board. 
A complete description of this system, describing all of the peripherals connected to
Nios~V, is available as part of the \texttt{Computer Organization} section of the
\texttt{Courses} tab on 
{\small \href{https://www.fpgacademy.org/courses.html} {FPGAcademy.org}}. 
\footnote{This computer system also includes an ARM A9 processor subsystem. It is 
described in the document entitled {\it DE1-SoC Computer System with ARM* Cortex* A9},
which is available on the 
{\small \href{https://www.fpgacademy.org/tutorials.html} {FPGAcademy.org}} website.}
 
\begin{figure}[H]
   \begin{center}
      \includegraphics[scale=0.85]{figures/Nios_V_system.pdf}
   \caption{A Nios~V system implemented on a DE1-SoC board.} 
	 \label{fig:system}
	 \end{center}
\end{figure}

\newpage
\section{Nios\textsuperscript{\textregistered} V Processor Architecture}

Nios~V is based on the RISC-V processor architecture that is described in detail on
the {\small \href{https://www.riscv.org} {riscv.org}} website. Useful information for
programmers using RISC-V can be found on the 
{\small \href{https://five-embeddev.com} {five-embeddev.com}} website.
Using the terminology from the RISC-V specification, Nios~V has features in
the {\it RV32IMZicsr} architecture. This mnemonic denotes a 32-bit processor that supports 
integer computations ({\it 32I}) including multiply and divide ({\it M}, available in
Nios~V/g), with special instructions that are used for control purposes ({\it Zicsr}). 

\section{Register Structure}
\label{sec:registers}

All registers in Nios~V are 32-bits long. There are 32 general-purpose registers, 
{\it x0} to {\it x31}, plus a program counter, {\it pc}. The general-purpose registers
are listed in Figure~\ref{fig:gp_regs} 
and are used for performing integer computations in program code. 

Register {\it x0} is referred to as the {\it zero} register.  It always contains the 
constant 0. Thus, reading this register returns the value 0, while writing to it has no effect.  

Most of the other general-purpose registers can be used interchangeably in practice. However, 
by convention software programs usually treat the registers in a particular way, as indicated
below:

\begin{itemize}
\item Registers {\it x1} is known as the {\it ra} register, because it is often used
to hold the {\it return address} from a subroutine. 
\item Register {\it x2} is known as the {\it sp} register, because it is typically used 
as the {\it stack pointer}. 
\item Registers {\it x3} and {\it x4} are used as special pointer registers by compilers
for high-level languages. These registers are referred to as the {\it global pointer} (gp) and 
{\it thread pointer} (tp), respectively. 
\item Registers {\it x5} to {\it x7} are known as {\it t0} to {\it t2}, because they are
conventionally used to hold {\it temporary} data. Data in these registers is not expected 
to be preserved over a subroutine call/return sequence. Register {\it x5} is also sometimes 
used by compilers to hold return addresses from subroutines.
\item Registers {\it x8} and {\it x9} are referred to as {\it s0} and {\it s1}, because 
they are conventionally used to hold data that should be {\it saved}, meaning that their 
values are expected to be preserved over a subroutine call/return sequence.
Register {\it x8} may also used by compilers as a stack {\it frame pointer}.
\item Registers {\it x10} to {\it x17} are known as the {\it a0} to {\it a7} registers, 
because they are conventionally used to hold the {\it arguments} for subroutines. 
Register {\it a0} is also intended to be used for the return value from a subroutine. 
\item Registers {\it x18} to {\it x27} are known as {\it s2} to {\it s11}. They are
additional {\it saved} registers, like {\it s0} and {\it s1}.
\item Registers {\it x28} to {\it x31} are known as {\it t3} to {\it t6}. They are
additional {\it temporary} registers, like {\it t0} to {\it t2}. 
\end{itemize}

\begin{figure}[H]
\begin{center}
\begin{tabular}{|l|l|l|} \hline 
\rule{0in}{0.1in}{\bf Register} & {\bf Name} & {\bf Conventional Usage} \\ \hline
x0 & zero & 0\\ 
x1 & ra & Return address\\ 
x2 & sp & Stack pointer\\ 
x3 & gp & Global pointer\\ 
x4 & tp & Thread pointer\\ 
x5 & t0 & Temporary / alternate return address\\ 
x6 & t1 & Temporary\\ 
x7 & t2 & Temporary\\
x8 & s0 & Saved / frame pointer\\
x9 & s1 & Saved\\
x10 & a0 & Subroutine argument / return value\\
x11 & a1 & Subroutine argument\\
$\cdots$ & $\cdots$ & $\cdots$ \\ 
x17 & a7 & Subroutine argument\\
x18 & s2 & Saved\\
x19 & s3 & Saved\\
$\cdots$ & $\cdots$ & $\cdots$ \\ 
x27 & s11 & Saved\\
x28 & t3 & Temporary\\ 
$\cdots$ & $\cdots$ & $\cdots$ \\ 
x31 & t6 & Temporary\\ \hline
\end{tabular}
\end{center}
	\caption{General-purpose registers.}
	\label{fig:gp_regs}
\end{figure}

Nios~V also has several 32-bit {\it control} registers, as indicated in
Figure~\ref{fig:ctrl_regs}. 
These control registers are used to report and control the operating state of the processor. 
The control registers are discussed in detail in Section~\ref{sec:control}. 

~~\
\begin{figure}[H]
\begin{center}
\begin{tabular}{|l|l|} \hline 
\rule{0in}{0.1in}{\bf Register} & {\bf Description} \\ \hline
mstatus & machine status register \\
misa & machine ISA register \\
mie & machine interrupt enable register \\
mtvec & machine trap vector register \\
mepc & machine exception pc register \\
mcause & machine cause register \\
mtval & machine trap value register \\
mip & machine interrupt pending register \\ \hline
\end{tabular}
\end{center}
	\caption{Control registers.}
	\label{fig:ctrl_regs}
\end{figure}

\section{Accessing Memory and I/O Devices}

The Nios~V processor issues 32-bit addresses. The memory space is byte-addressable, and is
organized in the little-endian style (the address of the least-significant byte in a word is
the same as the address of the word). 
Memory locations can be read and written as {\it words} (32 bits), {\it halfwords} (16 bits),
or {\it bytes} (8 bits) of data.
Any input/output devices that can be accessed by the
Nios~V processor are memory mapped and are accessed as memory locations. 

\section{Nios~V Instruction Set}

All Nios~V instructions are 32-bits long.  As shown in Figure~\ref{fig:insts}, 
these machine instructions are represented using four main types of binary encodings: 
{\it R}-type, {\it I}-type, {\it S}-type, and {\it U}-type. In all cases the seven 
bits $b_{6-0}$ denote the {\it opcode}. Seven-bit fields {\it funct7} and three-bit fields
{\it funct3} are used to extend the opcode and specify the operation to be executed.
The instruction formats use five-bit fields for specifying general-purpose source registers
({\it rs1} or {\it rs2}) or destination registers ({\it rd}). Finally, the 
remaining bits are used to specify immediate operands, which are sign-extended by Nios~V
(for most instructions) to provide 32-bit operands.

\begin{figure}[H]
   \begin{center}
      \includegraphics[scale=.55]{figures/insts.png}
   \caption{Formats of Nios~V instructions.} 
	 \label{fig:insts}
	 \end{center}
\end{figure}

In addition to machine instructions that are
executed directly by the processor, there are also a number of {\it pseudoinstructions} that
can be used in assembly-language programs.  The discussion below includes several examples 
of such pseudoinstructions, which the Assembler implements using (one, or more) machine 
instructions.

The following material discusses the main features of the Nios~V instruction set.
More complete descriptions, including details of how each instruction
is encoded, can be found online in the {\it RISC-V Instruction Set Manual}.

\subsection{Load and Store Instructions}

Load and store instructions are used to move data between memory (or I/0 interfaces)
and the general-purpose registers. These are the only instructions in the processor that can
directly access memory locations. All other types of instructions operate only on Nios V
registers. 

Load and store instructions are of I-type and S-type, respectively. Memory addresses are
formed by using a {\it base register} and an {\it offset value}. For example, the load word 
instruction
\vspace{-\baselineskip}
\begin{center}
{\sf lw~~rd, byte\_offset(rs1)}
\end{center}
\noindent
determines the effective address of a memory location as the sum of the value of the base
register {\it rs1} and the {\it byte\_offset} value. The {\it byte\_offset} is a 12-bit 
constant that is sign extended to 32 bits. The data word in memory at the effective address 
is loaded into register {\it rd}. Since a word of data is being loaded, the effective 
address must be {\it word-aligned} (that is, a multiple of four). 

As an example of {\sf lw}, assume that register {\it t1} is set to the 
value \texttt{0x1000} \footnote{Numbers can be 
specified in decimal (\texttt{4096}), hexadecimal (\texttt{0x1000}), or binary 
(\texttt{0b100000010010110}).}.  Then, the instruction
\vspace{-\baselineskip}
\begin{center}
{\sf lw~~t0, 8(t1)}
\end{center}
\noindent
loads the 32-bit word at memory address \texttt{0x1008} into register {\it t0}.

The store word instruction has the format
\vspace{-\baselineskip}
\begin{center}
{\sf sw~~rs2, byte\_offset(rs1)}
\end{center}
\noindent 
It stores the value of register {\it rs2} into the memory location at the address
computed as the sum of {\it byte\_offset} and the value of register {\it rs1}. 
 
There are load and store instructions that use operands that are only 8 or 16 bits long.
They are referred to as load/store byte and load/store halfword instructions, respectively.
Such load instructions are: {\sf lb} (load byte), {\sf lbu} (load byte unsigned),
{\sf lh} (load halfword), and {\sf lhu} (load halfword unsigned). 
When a shorter operand is loaded into a 32-bit register, its value has to be adjusted
to fit into the register. This is done by sign extending the 8- or 16-bit value to 32 bits
in the {\sf lb} and {\sf lh} instructions. In the {\sf lbu} and {\sf lhu} instructions
the operand is zero extended.

The corresponding store instructions are: {\sf sb} (store byte) and {\sf sh} (store halfword).
The {\sf sb} instruction stores the low byte of register {\it rs2} into the memory byte
specified by the effective address. The {\sf sh} instruction stores the low halfword
of register {\it rs2}. In this case the effective address must be {\it halfword-aligned}
(that is, a multiple of two).

When a load or store instruction does not require a {\it byte\_offset}, it can be omitted,
as in {\sf lw~~t0, (t1)} or {\sf st~~t0, (t1)}. This shortcut is considered a
pseudoinstruction by the Assembler. Other examples of short-form load and store
instructions can be found in the {\it RISC-V Instruction Set Manual}.

\subsection{Integer Arithmetic Instructions}

The integer arithmetic instructions operate on the data that is either in the general purpose 
registers or given as an immediate value in the instruction. These instructions are of 
R-type or I-type, respectively.

\subsubsection{Integer Addition and Subtraction}
\label{sec:addsub}

The instructions for adding or subtracting integer data are:
\vspace{-\baselineskip}
\begin{ctabbing}
~~~~\={\sf addi}~~\={\sf rd, rs1, imm}~~~~\=\kill
\>{\sf add} \>{\sf rd, rs1, rs2} \>(add registers)\\
\>{\sf addi} \>{\sf rd, rs1, imm} \>(add immediate)\\
\>{\sf sub} \>{\sf rd, rs1, rs2} \>(subtract registers)\\
\>{\sf neg} \>{\sf rd, rs1} \>(negate register)
\end{ctabbing}
\newpage
The instruction
\vspace{-\baselineskip}
\begin{center}
{\sf add~~rd, rs1, rs2}
\end{center}
\noindent
adds the values in registers {\it rs1} and {\it rs2}, and places the sum into register {\it rd}.
The instruction
\vspace{-\baselineskip}
\begin{center}
{\sf addi~~rd, rs1, imm}
\end{center}

\noindent
adds the value of register {\it rs1} and the sign-extended 12-bit immediate operand given 
in the instruction, and places the result into register {\it rd}.
The addition operation for both {\sf add} and {\sf addi} is the same for both signed and 
unsigned operands. If it is necessary to know whether an overflow occurred (either signed
or unsigned), then other instructions are needed. Overflow detection is discussed in 
in Section~\ref{sec:overflow}.

\noindent
The instruction
\vspace{-\baselineskip}
\begin{center}
{\sf sub~~rd, rs1, rs2}
\end{center}
\noindent
subtracts the value of register {\it rs2} from the value of register {\it rs1}, and places the 
result into register {\it rd}. If carry or overflow detection is needed, then this has to be 
done by using additional instructions, as explained in Section~\ref{sec:overflow}.

\noindent
There is no immediate version for subtraction, hence it is necessary to use 
\begin{center}
{\sf addi~~rd, rs1, -imm}
\end{center}
\vspace{-\baselineskip}
\noindent
The instruction
\vspace{-\baselineskip}
\begin{center}
{\sf neg~~rd, rs1}
\end{center}
\noindent
is a pseudoinstruction that sets {\it rd} to the arithmetic negative of {\it rs1}. It is
implemented as {\sf sub~~rd, x0, rs1}.

\subsubsection{Integer Comparison}
\label{sec:compare}

It is sometimes necessary to compare the values in registers and to record the results.
Such comparisons can be done using the instructions: 
\vspace{-\baselineskip}
\begin{ctabbing}
~~~~\={\sf sltiu}~~\={\sf rd, rs1, rs2}~~~~\=\kill
\>{\sf slt} \>{\sf rd, rs1, rs2} \>(set if less than)\\
\>{\sf sltu} \>{\sf rd, rs1, rs2} \>(set if less than unsigned)\\
\>{\sf slti} \>{\sf rd, rs1, rs2} \>(set if less than immediate)\\
\>{\sf sltiu} \>{\sf rd, rs1, rs2} \>(set if less than immediate unsigned)
\end{ctabbing}

\noindent
The instruction
\vspace{-\baselineskip}
\begin{center}
{\sf slt~~rd, rs1, rs2}
\end{center}
\noindent
sets {\it rd} to the value 1 if the value of register {\it rs1} is less than the
value of {\it rs2}, else sets {\it rd} to 0.

The instruction {\sf sltu} is the same as {\sf slt}, except that an unsigned comparison is done. 
\newpage
\noindent
The instruction
\vspace{-\baselineskip}
\begin{center}
{\sf slti~~rd, rs1, imm}
\end{center}
\noindent
sets {\it rd} to 1 if the value of register {\it rs1} is less than the sign-extended 12-bit
immediate operand, else sets {\it rd} to 0.

The instruction {\sf sltiu} is the same as {\sf slti}, except that an unsigned comparison
is done.

Several pseudoinstructions provide variants of the comparison instructions. Examples are:
\vspace{-\baselineskip}
\begin{ctabbing}
~~~~\={\sf seqz}~~\={\sf rd, rs1, rs2}~~~~\=\kill
\>{\sf seqz} \>{\sf rd, rs1} \>(set if equal to zero)\\
\>{\sf snez} \>{\sf rd, rs1} \>(set if not equal to zero)\\
\>{\sf sgtz} \>{\sf rd, rs1} \>(set if greater than zero)\\
\>{\sf sgt} \>{\sf rd, rs1, rs2} \>(set if greater than)\\
\>{\sf sgtu} \>{\sf rd, rs1, rs2} \>(set if greater than unsigned)\\
\>{\sf slt} \>{\sf rd, rs1, rs2} \>(set if less than)
\end{ctabbing}

\subsubsection{Integer Multiplication and Division}

Multiplication and division are supported in Nios~V/g. The instructions for multiplying 
integer data are:
\vspace{-\baselineskip}
\begin{ctabbing}
~~~~\={\sf mulhsu}~~\={\sf rd, rs1, rs2}~~~~\=\kill
\>{\sf mul} \>{\sf rd, rs1, rs2}\>(multiply)\\
\>{\sf mulh} \>{\sf rd, rs1, rs2}\>(multiply high-half)\\
\>{\sf mulhsu} \>{\sf rd, rs1, rs2}\>(multiply high-half signed/unsigned)\\
\>{\sf mulhu} \>{\sf rd, rs1, rs2}\>(multiply high-half unsigned)
\end{ctabbing}

\noindent
The instruction
\vspace{-\baselineskip}
\begin{center}
{\sf mul~~rd, rs1, rs2}
\end{center}
\noindent
multiplies the values of registers {\it rs1} and {\it rs2}, and places the {\it low-order}
32 bits of the product into register {\it rd}.  The instruction
\vspace{-\baselineskip}
\begin{center}
{\sf mulh~~rd, rs1, rs2}
\end{center}
\noindent
multiplies {\it rs1} $\times$ {\it rs2} and places the {\it high-order} 32 bits of the result 
into {\it rd}, using signed multiplication. The {\sf mulh} and {\sf mul} instructions
together generate a 64-bit signed multiplication.
 
The instruction {\sf mulhsu} is the same as {\sf mulh}, except that the value of register
{\it rs2} is treated as an unsigned number.  The {\sf mulhsu} and {\sf mul} instructions 
together generate a 64-bit signed $\times$ unsigned multiplication.
 
The instruction {\sf mulhu} is the same as {\sf mulh}, except that the values in both
registers {\it rs1} and {\it rs2} are treated as unsigned numbers.  The {\sf mulhu} and
{\sf mul} instructions together generate a 64-bit unsigned multiplication.

\newpage
The instructions for generating the results of integer division are:
\vspace{-\baselineskip}
\begin{ctabbing}
~~~~\={\sf remu}~~\={\sf rd, rs1, rs2}~~~~\=\kill
\>{\sf div} \>{\sf rd, rs1, rs2}\>(divide)\\
\>{\sf divu} \>{\sf rd, rs1, rs2}\>(divide unsigned)\\
\>{\sf rem} \>{\sf rd, rs1, rs2}\>(remainder)\\
\>{\sf remu} \>{\sf rd, rs1, rs2}\>(remainder unsigned)
\end{ctabbing}

\noindent
The instruction
\vspace{-\baselineskip}
\begin{center}
{\sf div~~rd, rs1, rs2}
\end{center}
\noindent
divides the value of register {\it rs1} by the value of {\it rs2} and places the integer
portion of the quotient into register {\it rd}. The operands are treated as signed numbers.
The {\sf divu} instruction is performed in the same way except that the operands are treated 
as unsigned numbers.

The {\sf rem} instruction sets {\it rd} to the remainder of {\it rs1} $\div$ {\it rs2},
using signed division. The {\sf remu} instruction is the same as {\sf rem}, except using unsigned
division.

\subsection{Logic Instructions}

The logic instructions implement the AND, OR, exclusive OR, and NOT logical operators. They 
operate on data that is either in the general purpose registers or given as an immediate
value. These instructions are of R-type or I-type, respectively. The logic instructions are:
\vspace{-\baselineskip}
\begin{ctabbing}
~~~~\={\sf XORi}~~\={\sf rd, rs1, imm}~~~~\=\kill
\>{\sf and} \>{\sf rd, rs1, rs2}\>(AND)\\
\>{\sf andi} \>{\sf rd, rs1, imm}\>(AND immediate)\\
\>{\sf or} \>{\sf rd, rs1, rs2}\>(OR)\\
\>{\sf ori} \>{\sf rd, rs1, imm}\>(OR immediate)\\
\>{\sf xor} \>{\sf rd, rs1, rs2}\>(exclusive OR)\\
\>{\sf xori} \>{\sf rd, rs1, imm}\>(exclusive OR immediate)\\
\>{\sf not} \>{\sf rd, rs1}\>(NOT)\\
\end{ctabbing}
\vspace{-\baselineskip}
The instruction
\vspace{-\baselineskip}
\begin{center}
{\sf and~~rd, rs1, rs2} 
\end{center}
\noindent
performs a bitwise logical AND of the values of registers {\it rs1} and {\it rs2}, and stores 
the result in register {\it rd}. Similarly, the instructions {\sf or} and {\sf xor}
perform the bitwise logical OR and XOR operations, respectively.  The instruction
\vspace{-\baselineskip}
\begin{center}
{\sf andi~~rd, rs1, imm} 
\end{center}
\noindent
performs a bitwise logical AND of the value of register {\it rs1} and the 12-bit immediate
operand, which is sign-extended to 32 bits, and stores the result in register {\it rd}.
Similarly, the instructions {\sf ori} and {\sf xori} perform the OR and exclusive~OR operations 
with immediate data, respectively.
The instruction
\vspace{-\baselineskip}
\begin{center}
{\sf not~~rd, rs1} 
\end{center}
\noindent
sets {\it rd} to the logical complement of {\it rs1}. It is a pseudoinstruction
implemented as {\sf xori~~rd, rs1, -1}.
\subsection{Shift Instructions}

These instructions shift the value of a register either to the right or to the left.
They are of R-type or I-type. They correspond to the shift operators $>$> and $<$< in the C 
programming language.  The shift instructions are:
\vspace{-\baselineskip}
\begin{ctabbing}
~~~~\={\sf srai}~~\={\sf rd, rs1, imm}~~~~\=\kill
\>{\sf sll} \>{\sf rd, rs1, rs2} \>(shift left logical)\\
\>{\sf slli} \>{\sf rd, rs1, uimm} \>(shift left logical immediate)\\
\>{\sf srl} \>{\sf rd, rs1, rs2} \>(shift right logical)\\
\>{\sf srli} \>{\sf rd, rs1, uimm} \>(shift right logical immediate)\\
\>{\sf sra} \>{\sf rd, rs1, rs2} \>(shift right arithmetic)\\
\>{\sf srai} \>{\sf rd, rs1, uimm} \>(shift right arithmetic immediate)
\end{ctabbing}

\noindent
The {\sf sll} instruction shifts the contents of register {\it rs1} to the left by the number 
of bit positions specified by the five least-significant bits (number in the range 0 to 31)
in register {\it rs2}, and stores the result in register {\it rd}. The vacated bits on the
right side of the shifted operand are filled with 0s.

\noindent
The {\sf slli} instruction shifts the contents of register {\it rs1} to the left by the number 
of bit positions specified by the five-bit unsigned value {\it uimm} given in the instruction.

\noindent
The {\sf srl} and {\sf srli} instructions are similar to the {\sf sll} and {\sf slli}
instructions, but they shift the value of register {\it rs1} to the right and fill the vacated
bits on the left side with 0s.

\noindent
The {\sf sra} and {\sf srai} instructions perform the same actions as the {\sf srl} and 
{\sf srli} instructions, except that the sign bit, {\it rs1}$_{31}$, is replicated into 
the vacated bits on the left side of the shifted operand.

\subsection{Data Movement Instructions}

A number of instructions are provided for moving data into registers. Examples are:

\vspace{-\baselineskip}
\begin{ctabbing}
~~~~\={\sf auipc}~~\={\sf rd, imm}~~~~\=\kill
\>{\sf mv} \>{\sf rd, rs1} \>(move register)\\
\>{\sf lui} \>{\sf rd, imm} \>(load upper immediate)\\
\>{\sf auipc} \>{\sf rd, imm} \>(add upper immediate and pc)\\
\>{\sf li} \>{\sf rd, imm} \>(load immediate)\\
\>{\sf la} \>{\sf rd, label} \>(load address)\\
\end{ctabbing}
\vspace{-\baselineskip}
The {\sf mv} instruction copies the value of register {\it rs1} into {\it rd}.
It is a pseudoinstruction implemented by using {\sf addi} with a zero operand.
The instruction
\vspace{-\baselineskip}
\begin{center}
{\sf lui~~rd, imm}
\end{center}
\noindent
copies the immediate operand into the {\it high-order} bits of {\it rd}. This instruction
is of U-type, which means that it supports a 20 bit {\it imm} operand. The {\sf lui}
instruction sets the lower 12 bits of {\it rd} to zero, which means that an instruction such as
{\sf addi} can be used to initialize those remaining bits. In this way, by using a combination 
of {\sf lui} and {\sf addi}, {\it rd} can be initialized to any 32-bit value. 

The instruction
\vspace{-\baselineskip}
\begin{center}
{\sf auipc~~rd, imm}
\end{center}
\noindent
sets {\it rd} to the sum of the current value of the program counter {\it pc} plus {\it imm}. 
This instruction is of U-type and the {\it imm} value is used as an upper-immediate in the 
same way as for the {\sf lui}
instruction. This means that {\it imm} is padded with 12 zeros in the least-significant bit 
positions before being added to {\it pc}. The {\sf auipc} instruction is not normally used
directly by a programmer. Instead, it is used by the Assembler whenever it is necessary to
calculate an address that is relative to the value of the program counter.
The instruction
\vspace{-\baselineskip}
\begin{center}
{\sf la~~rd, label}
\end{center}
\vspace{-\baselineskip}
\noindent
sets {\it rd} to the memory address associated with {\it label}.  Such a label could be
associated with any statement in an assembly language program. The {\sf la} pseudoinstruction 
is implemented as

\begin{ctabbing}
~~~~\={\sf auipc}~~\={\sf rd, rd, \%high(imm)}~~~~\=\kill
\>{\sf auipc} \>{\sf rd, \%high(label)} \>(initialize the upper 20 bits)\\
\>{\sf addi} \>{\sf rd, rd, \%low(label)} \>(add an appropriate 12-bit value)\\
\end{ctabbing}
\vspace{-\baselineskip}
where {\sf \%high(label)} is used to initialize the 20 most-significant bits of {\it rd}, and 
{\sf \%low(label)} is used to add an appropriate 12-bit signed number to produce the desired 
32-bit memory address. By using the {\sf auipc} instruction, the calculation of a label's
address works properly regardless of where the program is placed in the memory.

\noindent
The instruction
\vspace{-\baselineskip}
\begin{center}
{\sf li~~rd, imm}
\end{center}
\noindent
sets {\it rd} to the value of {\it imm}. This pseudoinstruction can be used to initialize
{\it rd} to any 32-bit value. In a case where {\it imm} fits into a 12-bit signed number, 
the pseudoinstruction is implemented as
\begin{ctabbing}
~~~~\={\sf addi}~~\={\sf rd, rd, \%high(imm)}~~~~\=\kill
\>{\sf addi~~rd, x0, imm}
\end{ctabbing}
\vspace{-\baselineskip}
But if {\it imm} is too large to be used as a 12-bit signed value, then
{\sf li} is implemented as the sequence of instructions
\begin{ctabbing}
~~~~\={\sf addi}~~\={\sf rd, rd, \%low(imm)}~~~~\=\kill
\>{\sf lui} \>{\sf rd, \%high(imm)} \>(initialize the upper 20 bits)\\
\>{\sf addi} \>{\sf rd, rd, \%low(imm)} \>(add an appropriate 12-bit value)\\
\end{ctabbing}
\vspace{-\baselineskip}
where {\sf \%high(imm)} is used to initialize the 20 most-significant bits of {\it rd}, and 
{\sf \%low(imm)} is used to add an appropriate 12-bit signed number to produce the desired 
32-bit value.

\subsection{Jump and Branch Instructions}
\label{sec:flow}

The flow of execution of a program can be changed, either unconditionally or
conditionally, by executing jump or branch instructions.  These instructions are:

\begin{ctabbing}
~~~~\={\sf bgeu}~~\={\sf rs1, rs2, label}~~~~\=\kill
\>{\sf jal} \>{\sf rd, target} \>(jump and link)\\
\>{\sf jalr} \>{\sf rd, rs1, imm} \>(jump and link register)\\
\>{\sf beq} \>{\sf rs1, rs2, label} \>(branch if equal)\\
\>{\sf bne} \>{\sf rs1, rs2, label} \>(branch if not equal)\\
\>{\sf bge} \>{\sf rs1, rs2, label} \>(branch if greater than or equal)\\
\>{\sf bgeu} \>{\sf rs1, rs2, label} \>(branch if greater than or equal unsigned)\\
\>{\sf blt} \>{\sf rs1, rs2, label} \>(branch if less than)\\
\>{\sf bltu} \>{\sf rs1, rs2, label} \>(branch if less than unsigned)
\end{ctabbing}
\noindent
The jump and link instruction
\vspace{-\baselineskip}
\begin{center}
{\sf jal~~rd, target}
\end{center}
\noindent
transfers execution unconditionally to the target address, which is usually a label in the
program. The {\sf jal} instruction also sets {\it rd} to the
word address immediately following the {\sf jal} ({\it pc} + 4), which means that this 
instruction can be used to effect a subroutine call and return sequence. In cases where the 
linkage register isn't needed, because the jump does not involve a subroutine, register {\it x0} 
can be used for {\it rd}. The {\sf jal} instruction is encoded using a variant of 
the U-type encoding. Its 20-bit signed immediate is encoded in a particular way and is used 
during execution as an offset that is added to the {\it pc} to reach the target address.
The range of the {\sf jal} instruction is $\pm 1$MB.
 
The {\sf jalr} instruction is of I-type. It forms its target address by summing the
12-bit signed {\it imm} value and register {\it rs1}. The {\it rd} register is set to the
address of the next instruction ({\it pc} + 4) in the same way as for {\sf jal}. 
By combining it with the {\sf lui} instruction, {\sf jalr} can jump to {\it any} 32-bit address:
first, {\sf lui} is used to load the 20 least-significant bits of the target address, and 
then {\sf jalr} adds the remaining 12 bits. Similarly, {\sf auipc} can be combined with
{\sf jalr} to jump to any 32-bit address relative to the {\it pc}. 

The conditional branch instruction
\vspace{-\baselineskip}
\begin{center}
{\sf beq~~rs1, rs2, label}
\end{center}
\noindent
transfers execution to {\it label} if the value of {\it rs1} is equal to the value of 
{\it rs2}. If these two registers do not contain the same value, then the instruction has
no effect. The other conditional branch instructions work in the same way, based on
their various conditions. The conditional branches are encoded using a variant of 
the S-type encoding. Its 12-bit signed immediate is encoded in a particular way and is used 
during execution as an offset that is added to the {\it pc} to reach the {\it label}.
The range of branch instructions is $\pm 4$KB.

There are also several jump and branch pseudoinstructions:
\begin{ctabbing}
~~~~\={\sf bgeu}~~\={\sf rs1, rs2, label}~~~~\=\kill
\>{\sf j} \>{\sf label} \>(jump)\\
\>{\sf jal} \>{\sf label} \>(jump and link)\\
\>{\sf ret} \>\>(return)\\
\>{\sf beqz} \>{\sf rs1, label} \>(branch if equal to zero)\\
\>{\sf bnez} \>{\sf rs1, label} \>(branch if not equal to zero)\\
\>{\sf bgtz} \>{\sf rs1, label} \>(branch if greater than zero)\\
\>{\sf bgez} \>{\sf rs1, label} \>(branch if greater than or equal to zero)\\
\>{\sf bltz} \>{\sf rs1, label} \>(branch if less than zero)\\
\>{\sf blez} \>{\sf rs1, label} \>(branch if less than or equal to zero)\\
\>{\sf bgt} \>{\sf rs1, rs2, label} \>(branch if greater than)\\
\>{\sf bgtu} \>{\sf rs1, rs2, label} \>(branch if greater than unsigned)\\
\>{\sf ble} \>{\sf rs1, rs2, label} \>(branch if less than or equal)\\
\>{\sf bleu} \>{\sf rs1, rs2, label} \>(branch if less than or equal unsigned)\\
\end{ctabbing}
\vspace{-\baselineskip}
The {\sf j~label} pseudoinstruction jumps unconditionally 
to the given {\it label}. It is implemented
as {\sf jal x0, label}. The {\sf jal~label} pseudoinstruction is implemented as
{\sf jal ra, label}.

The {\sf ret} pseudoinstruction is used to return from a subroutine to its caller. It is
implemented as {\sf jalr x0, ra, 0}.

The conditional branch instructions that end with {\sf z} compare {\it rs1} to the value 0.
For example, {\sf beqz} branches to {\it label} if the value of {\it rs1} is equal to 0. 
It is implemented as {\sf beq rs1, x0, label}. Similarly, the {\sf bnez}, {\sf bgtz},
{\sf bgez}, {\sf bltz}, and {\sf blez} instructions provide other conditions that 
compare {\it rs1} to 0.
The instructions {\sf bgt}, {\sf bgtu}, {\sf ble}, and {\sf bleu} provide additional 
conditions that compare {\it rs1} and {\it rs2}. 

\subsection{Miscellaneous Instructions}
\label{sec:misc}

Some miscellaneous Nios~V instruction that do not fit within the above categories are:
\begin{ctabbing}
~~~~\={\sf ecall}~~~~\=\kill
\>{\sf nop} \>(no operation)\\
\>{\sf ecall} \>(environment call)\\
\>{\sf mret} \>(machine return)\\
\>{\sf wfi} \>(wait for interrupt)\\
\end{ctabbing}
\vspace{-\baselineskip}
The {\sf nop} instruction doesn't have any effect and simply advances the program counter. 
It is a pseudoinstruction implemented as {\sf addi x0, x0, 0}.

The rest of the  miscellaneous instructions listed above
are used in the context of exceptions or interrupts,
which are discussed in detail in Section~\ref{sec:traps}. 

The {\sf ecall} instruction causes an exception to occur, with the exception code set to 
the value 3.

The {\sf mret} instruction is used at the end of a trap handler routine to return to the 
interrupted program.  

The purpose of the {\sf wfi} instruction is to pause the execution of a program until 
an interrupt occurs. In some cases, {\sf wfi} may have no effect and behave like a 
{\sf nop} instruction.

\section{Control Registers}
\label{sec:control}

As mentioned in Section~\ref{sec:registers}, Nios~V has a number of control registers
that are used to report and control the state of the processor. Figure~\ref{fig:control}
shows that each register contains a number of {\it bit-fields}, which serve 
different purposes, and each register has an associated address. These control-register
addresses are 12 bits wide and are not part of the normal memory address space. They  
are used by special instructions, described in Section~\ref{sec:csr_inst}, that can read 
and modify the control register contents. 

The control registers are used as follows:
\vspace{-\baselineskip}
\begin{itemize}
\item The {\it mstatus} (machine status) register reports and controls the
processor operating state. It has the bit fields:
\begin{itemize}
\item {\it MPP} (machine previous privilege): these bits have 
the value \texttt{11} for Nios~V. This setting represents {\it machine mode}, which is
the only processor {\it mode} implemented in Nios~V. Other RISC-V modes that may be
implemented in different processors are described in the document {\it The RISC-V Instruction
Set Manual Volume II: Privileged Architecture}, which is available on the
{\small \href{https://www.riscv.org} {riscv.org}} website. 
\item {\it MIE} (machine interrupt enable): this bit allows a programmer to control
interrupt handling for the Nios~V processor. Interrupts are disabled if 
{\it MIE} $= 0$ and enabled when {\it MIE} $= 1$.  Interrupts are discussed in 
Section~\ref{sec:interrupts}.
\end{itemize}
\item The {\it misa} (machine ISA) register reports the processor architecture.
Programmers can examine the bits of this register to see which features of the RISC-V
architecture have been included in Nios V. Bits $b_{31-30}$ indicate the bit-width of 
the processor. For Nios~V these bits have the value
\texttt{01}, denoting a 32-bit processor. Also, bit $b_8 = 1$ to indicate that integer 
computations are supported. If multiplication and division are supported then bit $b_{12}$
will be set to 1, and if single-precision floating point is supported then bit $b_{5}$
will be 1.
\item The {\it mie} (machine interrupt enable) register allows individual Nios~V
interrupts to be enabled or disabled:
\begin{itemize}
\item {\it MSIE} (machine software interrupt enable): disables or enables software
interrupts, which are discussed in Section~\ref{sec:exceptions}. Software interrupts are
disabled if {\it MSIE} $= 0$ and enabled when {\it MSIE}~$= 1$.
\item {\it MTIE} (machine timer interrupt enable): disables or enables interrupts from the
built-in Nios~V timer, which is discussed in Section~\ref{sec:timer}. 
Timer interrupts are disabled if {\it MTIE} $= 0$ and enabled when {\it MTIE}~$= 1$.

\begin{figure}[t]
   \begin{center}
      \includegraphics[scale=.9]{figures/control_registers.pdf}
   \caption{Nios~V control register bit-fields.} 
	 \label{fig:control}
	 \end{center}
\end{figure}

\item IRQ (interrupt request) enable: allows up to 16 external sources of hardware
interrupts to be disabled or enabled. Hardware interrupts are discussed in 
Section~\ref{sec:interrupts}. Setting each IRQ bit to 0 disables the corresponding
hardware interrupt and setting it to 1 enables the interrupt.
\end{itemize}
\item The {\it mtvec} (machine trap vector) register is used to hold the address to which
the Nios~V processor should jump when an exception occurs. Example code using the
{\it mtvec} register is given in Section~\ref{sec:exceptions}.  There are two bit-fields:
\begin{itemize}
\item {\it trap handler address}: a programmer stores into this field the address of a trap
handler routine.
\item {\it mode}: a programmer sets these bits to \texttt{00} when using the basic interrupt
mode, and to \texttt{01} for the vectored interrupt mode. Example code using the
{\it mode} field is given in Section~\ref{sec:modes}.
\end{itemize}
\item The {\it mepc} (machine exception program counter) register holds the address of
the instruction that was executing when an interrupt or other type of exception occurred.
This register is used by the {\it mret} instruction to effect a return from a trap handler
routine, as described in Section~\ref{sec:exceptions}.
\item The {\it mcause} (machine cause) register provides information that identifies the
cause of an exception or interrupt. There are two bit-fields:
\begin{itemize}
\item {\it interrupt}: when a trap occurs, this field is set to 1 if the trap was caused
by an interrupt, otherwise this field is set to 0.
\item {\it exception code}/IRQ: this field identifies the cause of a trap. For exceptions,
various possible {\it codes} are described in Section~\ref{sec:exceptions}. For
interrupts, this field gives the IRQ number of the interrupting device.
\end{itemize}
\item The {\it mtval} (machine trap value) register may provide information that is useful 
for handling a trap. For example, {\it mtval} could provide the address that caused an 
alignment exception.
\item The {\it mip} (machine interrupt pending) register indicates which interrupt(s) are 
pending: 
\begin{itemize}
\item {\it MSIP} (machine software interrupt pending): a programmer can set or reset this
bit by writing to a memory-mapped control register, described in Section~\ref{sec:exceptions}, 
which is used to effect a {\it software interrupt}.
\item {\it MTIP} (machine timer interrupt pending): this bit has the value 1 
if an interrupt from the Nios~V machine timer is pending. A programmer can reset this bit 
by writing to the machine timer registers, as discussed in Section~\ref{sec:timer}.
\item IRQ (interrupt request) pending: each of these bits has the value 1 if the
corresponding external interrupt is pending. 
A bit can be reset by following the required procedure for the
interrupting device. 
\end{itemize}
\end{itemize}
 
\subsection{Control Register Instructions}
\label{sec:csr_inst}

The Nios~V control registers can be read and written by the special instructions:
\begin{ctabbing}
~~~~\={\sf csrrwi}~~\={\sf rd, csr, uimm}~~~~\=\kill
\>{\sf csrrw} \>{\sf rd, csr, rs1} \>(CSR read/write)\\
\>{\sf csrrwi} \>{\sf rd, csr, uimm} \>(CSR read/write immediate)\\
\>{\sf csrrs} \>{\sf rd, csr, rs1} \>(CSR read/set)\\
\>{\sf csrrsi} \>{\sf rd, csr, uimm} \>(CSR read/set immediate)\\
\>{\sf csrrc} \>{\sf rd, csr, rs1} \>(CSR read/clear)\\
\>{\sf csrrci} \>{\sf rd, csr, uimm} \>(CSR read/clear immediate)\\
\end{ctabbing}
\vspace{-\baselineskip}
\noindent
Each of these instructions refers to a control register by its address, {\it csr}, as
given in Figure~\ref{fig:control}.  The instruction
\vspace{-\baselineskip}
\begin{center}
{\sf csrrw~~rd, csr, rs1} 
\end{center}
reads the value of the selected control register and copies it into {\it rd}. Then, the 
instruction writes the value of {\it rs1} into the control register bits (that are
writable). The {\sf csrrwi} instruction works in the same manner, except using an unsigned
immediate operand.
The instruction
\vspace{-\baselineskip}
\begin{center}
{\sf csrrs~~rd, csr, rs1} 
\end{center}
reads the value of the selected control register and copies it into {\it rd}. Then, the 
instruction uses the value in {\it rs1} as a bit-mask and sets the corresponding bits in the 
control register to \texttt{1}.  The {\sf csrrsi} instruction works in the same manner, 
except using an unsigned immediate operand.
Analogously, the {\sf csrrc} and {\sf csrrci} 
instructions are used to clear bits selected by the bit-mask in {\it rs1}. 

There are also several pseudoinstructions for use with control registers, which avoid the
need to specify the {\it zero} register when it would just serve as a placeholder:
\begin{ctabbing}
~~~~\={\sf csrrwi}~~\={\sf rs1, csr, uimm}~~~~\=\kill
\>{\sf csrc} \>{\sf csr, rs1} \>(CSR clear)\\
\>{\sf csrci} \>{\sf csr, uimm} \>(CSR clear immediate)\\
\>{\sf csrr} \>{\sf rd, csr} \>(CSR read)\\
\>{\sf csrs} \>{\sf csr, rs1} \>(CSR set)\\
\>{\sf csrsi} \>{\sf csr, uimm} \>(CSR set immediate)\\
\>{\sf csrw} \>{\sf csr, rs1} \>(CSR write)\\
\>{\sf csrwi} \>{\sf csr, uimm} \>(CSR write immediate)\\
\end{ctabbing}
\vspace{-\baselineskip}

\subsection{Nios~V Machine Timer and Software Interrupt Registers}
\label{sec:timer}
Nios~V includes a 64-bit internal timer that is available to application programmers. 
The timer is reset to 0 when the processor is powered on, and then monotonically
increases for every processor clock cycle. 
Since the timer is 64-bits wide, it will not overflow in any realistic amount
of time. The timer is accessible via two memory-mapped registers, called {\it mtime}
(machine time) and {\it mtimecmp} (machine time compare). The {\it mtime} register provides 
the current timer value, and the {\it mtimecmp} register can be used to cause a timer 
interrupt. A Nios~V timer interrupt will be pending whenever the value of {\it mtime} reaches or
exceeds the value of {\it mtimecmp}. Interrupts are discussed in Section~\ref{sec:interrupts}.

Since they are 64-bits wide, both {\it mtime} and {\it mtimecmp} comprise two 32-bit 
memory-mapped registers, one for the {\it low} word and the other for the {\it high} word. 
Hence, two {\sf lw} instructions are needed to read a value from each of these registers, and 
two {\sf sw} instructions are needed to write a value into each of them.

Nios~V also contains a memory-mapped register called {\it msip} (machine software interrupt
pending), which can be used by an application programmer to cause a 
{\it software interrupt}. Bit $b_0$ in this register is reflected in the {\it MSIP} bit of 
the {\it mip} register, from Figure~\ref{fig:control}. A programmer can create a software 
interrupt by writing a 1 into bit $b_0$ of the {\it msip} register. The other 31 bits 
in this register are not used. Interrupts are discussed further in Section~\ref{sec:interrupts}.

The {\it mtime}, {\it mtimecmp} and {\it msip} registers are part of a module in Nios~V called
the {\it Advanced Core Local Interrupt Specification} (ACLINT). As illustrated in 
Figure~\ref{fig:mm_control}, a {\it base} address is associated with the {\it ACLINT}, and 
each of the registers inside it has an address that is {\it offset} from this base. The value of
the {\it ACLINT} base address is system dependent. 

\begin{figure}[h]
   \begin{center}
      \includegraphics[scale=.9]{figures/mm_control_registers.pdf}
   \caption{Nios~V memory-mapped control registers.} 
	 \label{fig:mm_control}
	 \end{center}
\end{figure}

\newpage
\subsubsection{Carry and Overflow Detection}
\label{sec:overflow}

As pointed out in Section~\ref{sec:addsub}, the Nios~V addition and subtraction instructions 
perform the corresponding operations
in the same way for both signed and unsigned operands. The possible carry and arithmetic overflow
conditions are not detected, because Nios~V does not contain condition flags that might be set as
a result. These conditions can be detected by using additional instructions.

Assume that we are dealing with unsigned numbers and consider the {\sf add} instruction
\vspace{-\baselineskip}
\begin{center}
{\sf add~~t2, t1, t0}
\end{center}

Having executed this instruction, a possible occurrence of a carry out of the most-significant
bit (t2$_{31}$) can be detected by checking whether the unsigned sum (in register {\it t2}) 
is less than one of the unsigned operands. For example, if this instruction is followed by 
the instruction
\vspace{-\baselineskip}
\begin{center}
{\sf sltu} {\sf t3, t2, t0}
\end{center}

then the value of the carry bit will be in register {\it t3}.

\noindent
Similarly, if a branch is required when a carry occurs, this can be accomplished as follows:
\vspace{-\baselineskip}
\begin{center}
\begin{tabular}{ll}
{\sf add} & {\sf t2, t1, t0} \\
{\sf bltu} & {\sf t2, t0, label}
\end{tabular}
\end{center}

A test for arithmetic overflow can be done by checking the signs of the summands and the resulting
sum. An overflow occurs if two positive numbers produce a negative sum, or if two negative numbers
produce a positive sum. Using this approach, the overflow condition can control a conditional
branch as follows:
\vspace{-\baselineskip}
\begin{ctabbing}
~~~~\={\sf and}~~\={\sf t3, zero, label}~~~~\=\kill
\>{\sf add} \>{\sf t2, t0, t1} \>\# the required add operation\\
\>{\sf xor} \>{\sf t3, t2, t0} \>\# compare signs of sum and t0 \\
\>{\sf xor} \>{\sf t4, t2, t1} \>\# compare signs of sum and t1 \\
\>{\sf and} \>{\sf t3, t3, t4} \>\# set $\mathit{t3}_{31} = 1$ if ($(\mathit{t0}_{31} == \mathit{t1}_{31})~!=~\mathit{t2}_{31}$)\\
\>{\sf blt} \>{\sf t3, zero, label} \>\# branch if overflow occurred
\end{ctabbing}
\vspace{-\baselineskip}
A similar approach can be used to detect the carry and overflow conditions in subtract operations.
A carry out of the most-significant bit of the resulting difference can be detected by checking 
whether the first operand is less than the second operand. Thus, the carry can be used to control 
a conditional branch as follows:
\begin{center}
\begin{tabular}{ll}
{\sf sub} & {\sf t2, t1, t0} \\
{\sf bltu} & {\sf t1, t0, label}
\end{tabular}
\end{center}

\noindent
The arithmetic overflow in a subtract operation is detected by comparing the sign of the generated 
difference with the signs of the operands. Overflow occurs if the operands in registers
{\it t1} and {\it t0} have different signs, and the sign of the difference in register 
{\it t2} is different than the sign of {\it t1}.
Thus, a conditional branch based on the arithmetic overflow can be achieved as follows:
\begin{center}
\begin{tabular}{lll}
{\sf sub} & {\sf t2, t1, t0}~~~~~~~ & \# the required subtract operation \\
{\sf xor} & {\sf t3, t1, t0}  & \# compare signs of t1 and t0 \\
{\sf xor} & {\sf t4, t1, t2}  & \# compare signs of t1 and t2 \\
{\sf and} & {\sf t3, t3, t4}  & \# set $\mathit{t3}_{31} = 1$ if $((\mathit{t1}_{31}~!=~\mathit{t2}_{31})~\&\&~(\mathit{t1}_{31}~!=~\mathit{t2}_{31})$) \\
{\sf blt} & {\sf t3, zero, label} & \# branch if overflow occurred
\end{tabular}
\end{center}
 
\section{Assembler Directives}

The Nios~V Assembler conforms to the widely used GNU* Assembler, which is 
software available in the public domain. Thus, the GNU Assembler directives can
be used in Nios~V programs. Assembler directives begin with a period. 
We describe some of the more frequently-used assembler directives in
Figure~\ref{fig:directives}.

\begin{figure}[H]
\begin{center}
\begin{tabular}{p{.22\linewidth}|p{.7\linewidth}}
{\bf Directive} & {\bf Purpose} \\ \hline
\rule[-0.075in]{0in}{0.25in}{\sf .ascii}~~"{\it string}" & A string of ASCII characters is 
loaded into consecutive byte addresses in the memory.  Multiple strings, separated by commas, 
can be specified.\\
\rule[-0.075in]{0in}{0.33in}{\sf .asciz}~~"{\it string}" & The same as {\sf .ascii}, except 
that each string is followed (terminated) by a zero byte.\\
\rule[-0.075in]{0in}{0.33in}{\sf .byte}~~{\it expressions} & 
Expressions separated by commas are specified. Each expression is assembled into
a byte. Examples of expressions are: 8, 5 + LABEL, and K $-$ 6.\\
\rule[-0.075in]{0in}{0.33in}{\sf .data} & Identifies the data that should be placed in the 
data section of the memory. The desired memory location for the data section is system dependent.\\
\rule[-0.075in]{0in}{0.33in}{\sf .end} & 
Marks the end of the source code file; everything after this
directive is ignored by the Assembler.\\
\rule[-0.075in]{0in}{0.33in}{\sf .equ}~~{\it symbol,~expression} &
Sets the value of {\it symbol} to {\it expression}. This directive can also be specified
as {\sf .eqv}.\\
\end{tabular}
\end{center}
	\caption{Directives (Part $a$).}
	\label{fig:directives}
\end{figure}

\begin{center}
\begin{tabular}{p{.22\linewidth}|p{.7\linewidth}}
{\bf Directive} & {\bf Purpose} \\ \hline
\rule[-0.075in]{0in}{0.33in}{\sf .global}~~{\it symbol} & 
Makes {\it symbol} visible outside of the assembled object file.
This directive can also be specified as {\sf .globl}.\\
\rule[-0.075in]{0in}{0.33in}{\sf .hword}~~{\it expressions} & 
Expressions separated by commas are specified. Each expression is assembled into
a half-word (16-bit) number.\\
\rule[-0.075in]{0in}{0.33in}{\sf .include}~~"{\it filename}" &
Provides a mechanism for including supporting files in a source program.\\
\rule[-0.075in]{0in}{0.33in}{\sf .org}~~{\it new-lc} &
Advances the location counter to the address {\it new-lc}.
The {\sf .org} directive may only increase the location counter, or leave it unchanged; 
it cannot move the location counter backwards.\\
\rule[-0.075in]{0in}{0.33in}{\sf .skip}~~{\it size} & 
Emits the number of bytes specified in {\it size}; the value of each byte is zero.\\
\rule[-0.075in]{0in}{0.33in}{\sf .text} & 
Identifies the code that should be placed in the text section of the memory.
The desired memory location for the text section is system specific.\\
\rule[-0.075in]{0in}{0.33in}{\sf .word}~~{\it expressions} &
Expressions separated by commas are specified. Each expression is assembled into
a 32-bit value.
\end{tabular}

\vspace{0.25in}
Figure~\ref{fig:directives}. Directives (Part $b$).
\end{center}

\section{Example Program}

As an illustration of Nios~V instructions and assembler directives, 
Figure~\ref{fig:example} gives an assembly-language program
that computes a dot product of two vectors, {\it A} and {\it B}. The vectors
have $n$ elements. The required computation is
\begin{center}
Dot product $=$ $\sum_{i = 0}^{n - 1}$ A({\it i}) $\times$ B({\it i})
\end{center}

\noindent
The vectors are stored in memory locations at addresses
{\it Avector} and {\it Bvector}, respectively. The number of elements
is stored in memory location $N$. The computed result is written
into memory location {\it dot\_p}. Each vector element is assumed to be a
signed 32-bit number.

\noindent
The program ends by continuously looping to the {\it stop} label.

\begin{figure}[H]
\begin{lstlisting}[style=defaultNiosVStyle]
            .text
            .global _start
_start:     la      s0, Avector     # pointer to vector A
            la      s1, Bvector     # pointer to vector B
            la      t0, N           # pointer to N
            lw      s2, (t0)        # s2 = N (number of vector elements)
            li      s3, 0           # s3 will hold the final result
            
loop:       lw      a0, (s0)        # load next element of vector A
            lw      a1, (s1)        # load next element of vector B
            jal     mult            # compute product
            add     s3, s3, a0      # add to the sum
            addi    s0, s0, 4       # point to next element of vector A
            addi    s1, s1, 4       # point to next element of vector B
            addi    s2, s2, -1      # count down
            bnez    s2, loop

            la      t0, dot_p       # pointer to the final result
            sw      s3, (t0)        # store the result
stop:       j       stop

# Multiplies a0 x a1, using successive addition
# Returns the product in a0
mult:       mv      t0, zero        # product
            mv      t1, zero        # for checking sign of result
            bgez    a1, mloop       # is a1 a positive value?
            neg     a1, a1          # ...if not, then negate a1
            li      t1, 1           # remember to negate the product

mloop:      beqz    a1, mdone       # done adding yet?
            add     t0, t0, a0      # add the multiplier to the product
            addi    a1, a1, -1      # decrement the multiplicand
            j       mloop

mdone:      beqz    t1, mult_ret    # is sign of product correct?
            neg     t0, t0          # flip sign of result
mult_ret:   mv      a0, t0          # return result
            ret

            .data
N:          .word   6
Avector:    .word   5, 3, -6, 19, 8, 12
Bvector:    .word   2, 14, -3, 2, -5, 36
dot_p:      .word   0
\end{lstlisting}
	\caption{A program that computes the dot product of two vectors.}
	\label{fig:example}
\end{figure}

\newpage
In Figure~\ref{fig:example}, the directive
\begin{center}
\begin{lstlisting}[style=defaultNiosVStyle]
        .global _start
\end{lstlisting}
\end{center} 
\vspace{-\baselineskip}
\noindent
indicates to the Assembler that the label {\it \_start} is accessible outside of the
assembled object file. This is the default label that should be used to indicate to
the Linker program the beginning of the application program.

The assembled machine code will be placed into the memory starting 
at the beginning address of the {\it .text} segment.
The program includes some sample data, which illustrate how the {\sf .word} directive 
can be used to place data items into memory. The assembled data will be loaded into 
memory starting at the beginning address of the {\it .data} segment.

Since the program performs multiplication by using a subroutine, it can be executed on a
Nios~V/m processor, which does not have the RISC-V multiplication and division extension.
If the program were executed on a Nios~V/g processor, which does have the multiplication
and division extension, then the {\it mult} subroutine could be removed and replaced with a
{\sf mul} instruction. 

\section{Exceptions and Interrupts}
\label{sec:traps}

An unexpected change in the flow of execution in Nios~V programs can be caused by a
{\it trap}, which is either an
{\it exception} or {\it interrupt}. Exceptions are typically caused by error conditions,
described in Section~\ref{sec:exceptions}, and interrupts are caused by hardware devices
or software, discussed in Section~\ref{sec:interrupts}. The instruction that is executing 
when such an exception or interrupt occurs is not completed; instead, the instruction is
stopped and Nios~V transfers control to a {\it trap handler} routine.

\subsection{Exceptions}
\label{sec:exceptions}
An exception can occur as the result of an error condition, or it can be caused by
executing an {\sf ecall} instruction. When an exception happens Nios~V performs a number
of actions:
\vspace{-\baselineskip}
\begin{itemize}
\item The value of the {\it pc} is copied into the {\it mepc} register. 
\item Bit $b_{31}$ of the {\it mcause} register is set to 0, to indicate the occurrence of an
exception. Also, a unique {\it exception code} that identifies the specific type of exception that
has occurred is placed in {\it mcause}. Some examples of exception codes are: 
\begin{itemize}
\item 0 (instruction not word aligned): this exception occurs if Nios~V attempts to fetch
an instruction when the value of the {\it pc} is not a multiple of four.
\item 2 (illegal instruction): this exception occurs if the machine code fetched from the
{\it pc} address does not correspond to a supported Nios~V instruction.
\item 4 (load address not aligned): this exception occurs if {\sf lw} is executed
to read from an address that is not a multiple of four, or if {\sf lh} is executed to read
from an address that is not a multiple of two.
\item 6 (store address not aligned): this exception occurs if {\sf sw} is executed
to write to an address that is not a multiple of four, or if {\sf sh} is executed to write
to an address that is not a multiple of two.
\item 11 (ecall): this exception occurs when the environment
call instruction is executed.
\end{itemize}

Other exception codes also exist, and are described in the RISC-V specification.

\item For some exceptions a value is written into the {\it mtval} register. For example,
if an address alignment exception happens, then the faulty address would be written by
Nios~V into {\it mtval}.
\item The value of the {\it trap handler address} in the {\it mtvec} register is copied 
into the {\it pc}.
\end{itemize}

A typical trap handler routine would examine the contents of the {\it mcause} register to
determine why the exception happened, and then take an appropriate action.

\subsection{Interrupts}
\label{sec:interrupts}

By default interrupts are not enabled in Nios~V. To make interrupts visible to the
processor, software code must performs the following two actions:
\vspace{-\baselineskip}
\begin{itemize}
\item Set the {\it MIE} bit in the {\it mstatus} register to 1. 
\item For each source of interrupt that should be enabled, set the corresponding enable bit 
to 1 in the {\it mie} register.
\end{itemize}

When an interrupt occurs, its corresponding bit in the {\it mip} register will be set to
1, to show that the interrupt is pending.
If enabled, this interrupt will cause Nios~V to perform a number of actions:
\vspace{-\baselineskip}
\begin{itemize}
\item The currently-executing instruction is cancelled, and the value of the {\it pc} is 
copied into the {\it mepc} register. 
\item The value of the {\it MIE} bit in the {\it mstatus} register is set to 0, preventing
nested interrupts. 
\item Bit $b_{31}$ of the {\it mcause} register is set to 1, to indicate the occurrence of an
interrupt. Also, the IRQ (interrupt request) number of the interrupting device 
is written into the {\it exception code}/IRQ field of the {\it mcause} register. Possible
IRQ numbers are:
\begin{itemize}
\item 3 (software interrupt): this interrupt is pending when software writes a 1 into the
memory-mapped {\it msip} register, from Figure~\ref{fig:mm_control}. 
\item 7 (machine timer interrupt): this interrupt is pending when the value of {\it
mtime}, from Figure~\ref{fig:mm_control}, is greater than or equal to the value of {\it mtimecmp}. 
\item $\ge 16$ (external interrupt): each of these interrupts is pending when the corresponding
external device sends an interrupt request signal to Nios~V.
\end{itemize}
\item The value of the {\it trap handler address} is copied into the {\it pc}. Two schemes 
are supported for determining the trap address, depending on the {\it mode} bits in the 
{\it mtvec} register, from Figure~\ref{fig:control}.  The possible mode bit values are:
\begin{itemize}
\item 00 ({\it Basic mode}): for all interrupts, the {\it trap handler address} in the 
{\it mtvec} register is copied into the {\it pc}.
\item 01 ({\it Vectored mode}): the trap address depends on the interrupt's IRQ number. 
The address written into the {\it pc} is calculated as the {\it trap handler address} in
{\it mtvec} plus $4 \times $IRQ. 
\footnote{\label{foot:vectored} At this time Nios~V does not support the RISC-V 
vectored interrupt mode. It is described here for completeness and for future use.}
\end{itemize}
\end{itemize}

For each interrupt, the trap handler routine typically executes specific software code that
clears the source of the IRQ and performs whatever actions are needed to service it. The trap 
handler then returns to the interrupted program by executing the {\sf mret} instruction. 

\subsubsection{Software Interrupts}
\label{sec:swi}

As indicated above, a software program can cause a software interrupt to become pending by
writing a 1 into bit $b_0$ of the {\it msip} register, from Figure~\ref{fig:mm_control}.
This bit-value will be reflected in the {\it MSIP} bit in the {\it mip} register shown 
in Figure~\ref{fig:control}. If this interrupt is enabled, the normal interrupt processing 
actions described above will take place. The software interrupt can be cleared by writing a 0 
into bit $b_0$ of the {\it msip} register.

\subsection{Interrupts Processing Examples}
\label{sec:modes}

Figure~\ref{fig:ints} gives an example of code that uses the basic Nios~V trap handling mode.
The code
enables interrupts from the Nios~V machine timer and uses them to display a one-second binary
counter on an output port that has a set of red lights (LEDs). The addresses of the timer
registers, {\it mtime} and {\it mtimecmp}, as well as the red light port, called {\it LEDR},
are taken from the {\it DE1-SoC Computer System with Nios~V}, shown in
Figure~\ref{fig:system}. 

Lines~\ref{line:equ1}~and~\ref{line:equ2} in Figure~\ref{fig:ints}$a$ define some symbolic 
names that are used in the code for the I/O addresses. The symbol {\it onesecond}
defined in Line~\ref{line:equ3} has the value 100~million, which is the number of timer 
cycles needed to provide a timeout every one second in the DE1-SoC system.

Line~\ref{line:sp} initializes the stack pointer to an address within the 64~MB SDRAM 
in the DE1-SoC system, and Line~\ref{line:timer} calls a subroutine that initializes the timer. 
Interrupts are enabled in Lines~\ref{line:int1}~to~\ref{line:int2}. First, the address of
the trap handler routine is written into the {\it mtvec} register, and then machine timer 
interrupts are enabled by setting bit $b_7$ of the {\it mie} register. Finally, interrupts 
are enabled in Nios~V by setting bit $b_3$ of the {\it mstatus} register.

\begin{figure}[h]
\begin{center} \begin{minipage}[h]{15 cm}
\begin{lstlisting}[style=defaultNiosVStyle, name=ints, numbers=left, escapechar=|]
            |\label{line:equ1}|.equ    LEDR_BASE, 0xff200000
            |\label{line:equ2}|.equ    MTIME_BASE, 0xff202100
            |\label{line:equ3}|.equ    onesecond, 100000000
            .text
            .global _start
|\label{line:sp}|_start:     li      sp, 0x40000      # initialize the stack location
            |\label{line:timer}|jal     set_timer        # initialize the timer
     
            |\label{line:int1}|la      t0, handler
            csrw    mtvec, t0        # set trap address
            li      t0, 0b10000000   # set the enable pattern
            csrs    mie, t0          # enable timer interrupts
            |\label{line:int2}|csrsi   mstatus, 0x8     # enable global interrupts

            |\label{line:wfi1}|la      s0, counter      # pointer to counter
            la      s1, LEDR_BASE    # pointer to red lights
            sw      zero, (s1)       # turn off all lights
loop:       wfi
            lw      t0, (s0)         # load the counter value
            sw      t0, (s1)         # write to the lights
            |\label{line:wfi2}|j       loop
\end{lstlisting}
	\caption{An example program using basic interrupts (Part $a$).}
	\label{fig:ints}
\end{minipage}
\end{center}
\end{figure}

\begin{center}
\begin{minipage}[h]{15 cm}
\begin{lstlisting}[style=defaultNiosVStyle, name=ints, numbers=left, escapechar=|]
# Trap handler
|\label{line:trap1}|handler:    addi    sp, sp, -8       # save regs that will be modified
            sw      t1, 4(sp)
            sw      t0, (sp)
            # check for cause of trap
            csrr    t0, mcause       # read mcause register
            |\label{line:xor}|li      t1, 0x80000007   # pattern to check interrupt bit
                                     # and IRQ = 7
|\label{line:stay}|stay:       bne     t0, t1, stay     # unexpected cause of exception
            
            # Restart the timer. This is one way to clear the interrupt
            |\label{line:clear1}|la      t0, MTIME_BASE
            |\label{line:clear2}|sw      zero, 8(t0)

            |\label{line:inc1}|la      t0, counter      # pointer to counter
            lw      t1, (t0)         # read counter value
            addi    t1, t1, 1        # increment the counter
            |\label{line:inc2}|sw      t1, (t0)         # store counter to memory

            lw      t0, (sp)         # restore regs
            lw      t1, 4(sp)
            addi    sp, sp, 8
            |\label{line:trap2}|mret

# Set timeout to 1 second
set_timer:  la      t0, MTIME_BASE   # set address
            sw      zero, 8(t0)      # reset low word of mtime
            sw      zero, 0xc(t0)    # reset high word of mtime
            
            li      t1, onesecond
            sw      t1, (t0)         # set mtimecmp low word
            sw      zero, 4(t0)      # set mtimecmp high word
            ret
     
            .data
counter:    .word   0                # the counter to be displayed\end{lstlisting}

\vspace{0.25in}
Figure~\ref{fig:ints}.	An example program using basic interrupts (Part $b$).
\end{minipage}
\end{center}

Lines~\ref{line:wfi1}~to~\ref{line:wfi2} in Figure~\ref{fig:ints}$a$ 
display the counter value in an endless loop,
waiting for an interrupt to occur on each iteration. 

The trap handler routine is given in Lines~\ref{line:trap1}~to~\ref{line:trap2} of
Figure~\ref{fig:ints}$b$.  It first saves the temporary registers that will be modified
({\it t0} and {\it t1}), and then reads the {\it mcause} register. To ensure that a timer
interrupt has occurred, Line~\ref{line:xor} checks that the interrupt bit, $b_{31}$, in
{\it mcause} has the value 1, and the exception code field is equal to 7. If this check is not
satisfied, then some kind of error has occurred and the code stops on
Line~\ref{line:stay}. Otherwise, the handler resets the timer, in
Line~\ref{line:clear2}. This action {\it clears} the timer 
interrupt, since it makes the value of {\it mtime} less than the value of 
{\it mtimecmp}. Also, this action resets the timer for its next timeout. 

Lines~\ref{line:inc1}~to~\ref{line:inc2} of Figure~\ref{fig:ints}$b$ increment the counter
value that is being displayed on the red lights by the main program. Finally, the last
part of the trap handler restores the temporary registers that it has modified and then 
executes the {\sf mret} instruction to return to the interrupted program.

The code that initializes the machine timer is shown at the end of
Figure~\ref{fig:ints}$b$. It simply sets {\it mtime} to 0 and {\it mtimecmp} to 100~million,
providing one-second timeouts based on its 100~MHz clock signal. 

Instead of resetting {\it mtime} to zero in the trap handler, as described above, another way
of handling the timer would be to increment {\it mtimecmp} when each interrupt occurs. 
This approach is more complex, but would be preferable in a system where it is not desirable 
to reset the {\it mtime} value. For this alternative approach, Figure~\ref{fig:set_timer} 
shows a version of {\it set\_timer} that initializes {\it mtimecmp} to the current value of 
the 64-bit {\it mtime} register. This operation requires a loop to check for overflow from 
the low-to-high 32-bit parts of {\it mtime} that could happen during the read operation. 
The code then adds 100~million to the current time value and stores the resulting sum into
{\it mtimecmp}, accounting for the carry that could be involved in this 64-bit operation.
Figure~\ref{fig:trap_mtimecmp} shows the part of the corresponding 
trap handler that would need to be changed for this alternative approach, which increments
{\it mtimecmp}. 

Figure~\ref{fig:vectored} gives an example of code that uses the vectored interrupt
mode (see Note~\ref{foot:vectored}). Two types of interrupts are used in this example:
a software interrupt and timer interrupts. A key difference from the
code in Figure~\ref{fig:ints} is illustrated in Lines~\ref{line:v1}~to~\ref{line:v2}, 
which write the handler address into {\it mtvec}, but with its {\it mode} bits set to the
value 01. Also, Lines~\ref{line:en1}~and~\ref{line:en2} set two interrupt enable bits in
{\it mie}: bit $b_7$ (machine timer) and bit $b_3$ (software interrupt). 

A software interrupt is generated by the code in Lines~\ref{line:sw1}~to~\ref{line:sw2},
by writing a 1 into bit $b_0$ of the {\it msip} register.

\begin{figure}[H]
\begin{center}
\begin{minipage}[h]{16 cm}
\begin{lstlisting}[style=defaultNiosVStyle, name=vecs, numbers=left, escapechar=|]
# Set timeout to 1 second
set_timer:  la      t0, MTIME_BASE   # set address
            # read the current time
tloop:      lw      t2, 0xc(t0)      # read mtime high
            lw      t1, 8(t0)        # read mtime low
            lw      t3, 0xc(t0)      # read high again
            bne     t3, t2, tloop    # check for overflow from low to high
            
            # current time is t2:t1
            li      t3, onesecond
            add     t3, t3, t1       # add one second to current time
            sw      t3, (t0)         # write to mtimecmp low
            sltu    t3, t3, t1       # check for carry-out
            add     t2, t2, t3       # increment (t3 = carry-out)
            sw      t2, 4(t0)        # write to mtimecmp high

            ret
\end{lstlisting}
	\caption{An alternative way of initializing the timer.}
	\label{fig:set_timer}
\end{minipage}
\end{center}
\end{figure}

\begin{figure}[H]
\begin{center}
\begin{minipage}[h]{16 cm}
\begin{lstlisting}[style=defaultNiosVStyle, name=vecs, numbers=left, escapechar=|]
            |\ldots| code |not| shown
            # update the timer for the next interrupt cycle
            la      t0, MTIME_BASE
            lw      t1, (t0)         # read mtimecmp low
            li      t2, onesecond
            add     t2, t2, t1       # add one second to mtimecmp
            sw      t2, (t0)         # write to mtimecmp low
            sltu    t2, t2, t1       # check for carry-out from addition

            lw      t1, 4(t0)        # read mtimecmp high
            add     t1, t1, t2       # increment (t2 = carry-out)
            sw      t1, 4(t0)        # write to mtimecmp high
            |\ldots| code |not| shown
\end{lstlisting}
	\caption{Part of the trap handler for the alternative approach.}
	\label{fig:trap_mtimecmp}
\end{minipage}
\end{center}
\end{figure}

\begin{figure}[H]
\begin{center}
\begin{minipage}[h]{15 cm}
\begin{lstlisting}[style=defaultNiosVStyle, name=vecs, numbers=left, escapechar=|]
            |$\ldots$| directives (see |Figure~\ref{fig:ints}) not| shown

            .text
            .global _start
_start:     li      sp, 0x40000      # initialize the stack location
            jal     set_timer        # initialize the timer 
     
            |\label{line:v1}|la      t0, handler      # get handler address
            ori     t0, t0, 0b1      # set vector mode
            |\label{line:v2}|csrw    mtvec, t0        # set trap address and mode
            |\label{line:en1}|li      t0, 0b10001000   # set the enable pattern
            |\label{line:en2}|csrs    mie, t0          # timer & software interrupts
            csrsi   mstatus, 0x8     # enable global interrupts

            # Make a software interrupt happen
            |\label{line:sw1}|la      t0, MTIME_BASE   # base address
            li      t1, 1            # pattern to write to msip
            |\label{line:sw2}|sw      t1, 0x10(t0)     # write to msip (sw interrupt)

            |\label{line:mret}|la      s0, counter      # pointer to counter
            la      s1, LEDR_BASE    # pointer to red lights
|\label{line:wfi}|loop:       wfi
            lw      t0, (s0)         # load the counter value
            sw      t0, (s1)         # write to the lights
            |\label{line:loop}|j       loop
\end{lstlisting}
	\caption{An example program using vectored interrupts (Part $a$).}
	\label{fig:vectored}
\end{minipage}
\end{center}
\end{figure}

\begin{center}
\begin{minipage}[h]{15 cm}
\begin{lstlisting}[style=defaultNiosVStyle, name=vecs, numbers=left, escapechar=|]
# Trap handler
|\label{line:h1}|handler:    j       exception
            .org    handler + 3 * 4  # IRQ 3: software interrupt
            |\label{line:irq3}|j       IRQ_3
            .org    handler + 7 * 4  # IRQ 7: timer interrupt
            |\label{line:h2}|j       IRQ_7

exception:  j       exception        # not handled in this code
            
# software interrupt handler
IRQ_3:      addi    sp, sp, -8       # save regs that will be modified
            sw      t1, 4(sp)
            sw      t0, (sp)

            la      t0, MTIME_BASE   # base address
            |\label{line:clr}|sw      zero, 0x10(t0)   # clear software interrupt in msip
            la      t0, counter      # pointer to the counter
            li      t1, 0b1111111110
            sw      t1, (t0)         # write to the counter

            lw      t0, (sp)         # restore regs
            lw      t1, 4(sp)
            addi    sp, sp, 8
            mret

# timer interrupt handler
IRQ_7:      addi    sp, sp, -8       # save regs that will be modified
            sw      t1, 4(sp)
            sw      t0, (sp)
            
            # Restart the timer
            la      t0, MTIME_BASE
            sw      zero, 8(t0)      # write to mtime

            |$\ldots$| some code |not shown (see Figure~\ref{fig:ints})|
            |\label{line:mret2}|mret

set_timer:  |$\ldots$| code |not shown (see Figure~\ref{fig:ints})|
            ret

            .data
counter:    .word   0                # the counter to be displayed
\end{lstlisting}

\vspace{0.25in}
Figure~\ref{fig:vectored}.	An example program using vectored interrupts (Part $b$).
\end{minipage}
\end{center}

Lines~\ref{line:h1}~to~\ref{line:h2} of Figure~\ref{fig:vectored}$b$ provide three
trap vectors, at the addresses: {\it handler}, {\it handler} + 12, and {\it handler} + 28.
The vector at the address {\it handler} would be used in this code for any exception that
occurs. No exceptions are expected in this example program, so the code simply jumps to the
endless loop at Line~\ref{line:h1} if an extraneous exception should happen to occur. 

As mentioned above, a software interrupt is created in this example when a 1 is written
into the {\it msip} register by the store operation in Line~\ref{line:sw2} of 
Figure~\ref{fig:vectored}$a$. In response to the corresponding pending interrupt,
the processor will jump to the vector address {\it handler} + 12. The instruction at this address
(see Line~\ref{line:irq3} of Figure~\ref{fig:vectored}$b$)
then jumps to the label IRQ\_3, which provides the software interrupt handler. 
After saving temporary registers that it will modify, the handler clears the pending
interrupt by writing 0 into the {\it msip} register, in Line~\ref{line:clr}. Then, the
handler writes a pattern to illuminate all ten red lights in the LEDR output port, so that
a user can visually confirm that the software interrupt handler has been executed.
Finally, the handler restores temporary register values and then executes {\sf mret} to 
return to (Line~\ref{line:mret} of) the main program.

The main program in Figure~\ref{fig:vectored}$a$ will execute the loop between 
Lines~\ref{line:wfi} and~\ref{line:loop} indefinitely. Each time the machine timer
reaches its one-second timeout, the processor will jump to the vector address {\it handler} + 28.
The instruction at this address (see Line~\ref{line:h2} of Figure~\ref{fig:vectored}$b$)
then jumps to the label IRQ\_7, which provides the 
machine timer interrupt handler. Most of the code in this handler is not shown, because it
is the same as the code that we described previously for Figure~\ref{fig:ints}, except that this
handler has to save onto the stack the temporary registers that it will modify. Once this 
handler is completed, it restores saved temporary registers and then 
executes the {\sf mret} instruction in Line~\ref{line:mret2}
to return to the interrupted loop in the main program.

% Copyright and Trademark

\input{\commonPath/Docs/copyright.tex}

\end{document}

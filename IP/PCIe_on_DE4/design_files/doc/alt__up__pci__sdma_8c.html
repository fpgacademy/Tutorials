<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>alt_up_driver_codes: alt_up_pci_sdma.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>alt_up_pci_sdma.c File Reference</h1>  </div>
</div>
<div class="contents">

<p>The source file for the simple DMA controller functions.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="alt__up__pci__sdma_8h_source.html">alt_up_pci_sdma.h</a>&quot;</code><br/>

<p><a href="alt__up__pci__sdma_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="alt__up__pci__sdma_8c.html#a35e0a49125b0d6417e5718a304ad5f5e">alt_up_pci_sdma_set</a> (struct <a class="el" href="structalt__up__dma__ctrller.html">alt_up_dma_ctrller</a> *myctrller, u32 local_addr, u32 phys_addr, u32 length, int to_device)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The function to set the DMA controller.  <a href="#a35e0a49125b0d6417e5718a304ad5f5e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="alt__up__pci__sdma_8c.html#ae57315e0561c13c22f44074ae12f8081">alt_up_pci_sdma_clear</a> (struct <a class="el" href="structalt__up__dma__ctrller.html">alt_up_dma_ctrller</a> *myctrller)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The function to clear registers of DMA controller.  <a href="#ae57315e0561c13c22f44074ae12f8081"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="alt__up__pci__sdma_8c.html#a267db0a53da4a3f01941940713a25a15">alt_up_pci_sdma_polling</a> (struct <a class="el" href="structalt__up__dma__ctrller.html">alt_up_dma_ctrller</a> *myctrller)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The function to poll the result.  <a href="#a267db0a53da4a3f01941940713a25a15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="alt__up__pci__sdma_8c.html#ad1a28dba9f715da7a243f985699e72fe">alt_up_pci_sdma_interrupt</a> (struct <a class="el" href="structalt__up__dma__ctrller.html">alt_up_dma_ctrller</a> *myctrller)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The function to use interrupt.  <a href="#ad1a28dba9f715da7a243f985699e72fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="alt__up__pci__sdma_8c.html#ad642a47cbcaf420c34ae6d0d7f955992">alt_up_pci_sdma_init</a> (struct <a class="el" href="structalt__up__dma__ctrller.html">alt_up_dma_ctrller</a> *myctrller, int transfer_data_width)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The function to initialize the DMA controller.  <a href="#ad642a47cbcaf420c34ae6d0d7f955992"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="alt__up__pci__sdma_8c.html#ae2fb74fa05cd8232d71585f046b00f11">alt_up_pci_sdma_exit</a> (struct <a class="el" href="structalt__up__dma__ctrller.html">alt_up_dma_ctrller</a> *myctrller)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The function is called when the DMA controller is no longer used.  <a href="#ae2fb74fa05cd8232d71585f046b00f11"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="alt__up__pci__sdma_8c.html#acc48b18757603afd2a9c3bddfcf95ed7">alt_up_pci_sdma_go</a> (struct <a class="el" href="structalt__up__dma__ctrller.html">alt_up_dma_ctrller</a> *myctrller, int use_interrupt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The function to set go for DMA transfers.  <a href="#acc48b18757603afd2a9c3bddfcf95ed7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="alt__up__pci__sdma_8c.html#af220e3fdd4b481e29010525dfe5d8583">alt_up_pci_sdma_swreset</a> (struct <a class="el" href="structalt__up__dma__ctrller.html">alt_up_dma_ctrller</a> *myctrller)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The function to do the software reset.  <a href="#af220e3fdd4b481e29010525dfe5d8583"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The source file for the simple DMA controller functions. </p>
<p>The implementation of the funtions in this file is very basic and they are intended to provide and example of how to use the DMA controller. You will have to change them to improve the performance or satisfy your own need. </p>

<p>Definition in file <a class="el" href="alt__up__pci__sdma_8c_source.html">alt_up_pci_sdma.c</a>.</p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ae57315e0561c13c22f44074ae12f8081"></a><!-- doxytag: member="alt_up_pci_sdma.c::alt_up_pci_sdma_clear" ref="ae57315e0561c13c22f44074ae12f8081" args="(struct alt_up_dma_ctrller *myctrller)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void alt_up_pci_sdma_clear </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structalt__up__dma__ctrller.html">alt_up_dma_ctrller</a> *&nbsp;</td>
          <td class="paramname"> <em>myctrller</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The function to clear registers of DMA controller. </p>
<p>This function clear the status and control registers after the DMA transfer finished. The interrupt signal should be also cleared by this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>myctrller</em>&nbsp;</td><td>The DMA controller selected </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="alt__up__pci__sdma_8c_source.html#l00268">268</a> of file <a class="el" href="alt__up__pci__sdma_8c_source.html">alt_up_pci_sdma.c</a>.</p>

<p>References <a class="el" href="alt__up__pci__dma_8h_source.html#l00056">alt_up_dma_ctrller::dma_ctrl_base_addr</a>.</p>

<p>Referenced by <a class="el" href="alt__up__pci__sdma_8c_source.html#l00106">alt_up_pci_sdma_go()</a>, and <a class="el" href="alt__up__pci__sdma_8c_source.html#l00039">alt_up_pci_sdma_init()</a>.</p>

</div>
</div>
<a class="anchor" id="ae2fb74fa05cd8232d71585f046b00f11"></a><!-- doxytag: member="alt_up_pci_sdma.c::alt_up_pci_sdma_exit" ref="ae2fb74fa05cd8232d71585f046b00f11" args="(struct alt_up_dma_ctrller *myctrller)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alt_up_pci_sdma_exit </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structalt__up__dma__ctrller.html">alt_up_dma_ctrller</a> *&nbsp;</td>
          <td class="paramname"> <em>myctrller</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The function is called when the DMA controller is no longer used. </p>
<p>This function will free all the memory allocated in <a class="el" href="alt__up__pci__sdma_8c.html#ad642a47cbcaf420c34ae6d0d7f955992" title="The function to initialize the DMA controller.">alt_up_pci_sdma_init()</a>. The function is called in <a class="el" href="alt__up__pci__driver_8c.html#a19966fbca3121fec945733d9ae6e576c">alt_up_pci_dev_exit()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>myctrller</em>&nbsp;</td><td>The DMA controller selected </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="alt__up__pci__sdma_8c_source.html#l00087">87</a> of file <a class="el" href="alt__up__pci__sdma_8c_source.html">alt_up_pci_sdma.c</a>.</p>

<p>References <a class="el" href="alt__up__pci__sdma_8h_source.html#l00032">sdma::bus_addr</a>, <a class="el" href="alt__up__pci__dma_8h_source.html#l00078">alt_up_dma_ctrller::pci_dev</a>, <a class="el" href="alt__up__pci__dma_8h_source.html#l00080">alt_up_dma_ctrller::private_data</a>, <a class="el" href="alt__up__pci__sdma_8h_source.html#l00017">SDMA_BUF_SIZE</a>, and <a class="el" href="alt__up__pci__sdma_8h_source.html#l00030">sdma::virt_addr</a>.</p>

<p>Referenced by <a class="el" href="alt__up__pci__driver_8c_source.html#l00635">alt_up_pci_dev_exit()</a>.</p>

</div>
</div>
<a class="anchor" id="acc48b18757603afd2a9c3bddfcf95ed7"></a><!-- doxytag: member="alt_up_pci_sdma.c::alt_up_pci_sdma_go" ref="acc48b18757603afd2a9c3bddfcf95ed7" args="(struct alt_up_dma_ctrller *myctrller, int use_interrupt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int alt_up_pci_sdma_go </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structalt__up__dma__ctrller.html">alt_up_dma_ctrller</a> *&nbsp;</td>
          <td class="paramname"> <em>myctrller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>use_interrupt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The function to set go for DMA transfers. </p>
<p>This function will do all the transcations in the dma_queue. If the transfer size is larger than the SDMA_BUF_SIZE, it will automatically divide the transfer into multiple tranfers.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>myctrller</em>&nbsp;</td><td>The DMA controller selected </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>use_interrupt</em>&nbsp;</td><td>if 1, set the DMA controller to assert irq signal</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0 on success, -1 otherwise </dd></dl>

<p>Definition at line <a class="el" href="alt__up__pci__sdma_8c_source.html#l00106">106</a> of file <a class="el" href="alt__up__pci__sdma_8c_source.html">alt_up_pci_sdma.c</a>.</p>

<p>References <a class="el" href="alt__up__pci__sdma_8c_source.html#l00268">alt_up_pci_sdma_clear()</a>, <a class="el" href="alt__up__pci__sdma_8c_source.html#l00305">alt_up_pci_sdma_interrupt()</a>, <a class="el" href="alt__up__pci__sdma_8c_source.html#l00281">alt_up_pci_sdma_polling()</a>, <a class="el" href="alt__up__pci__sdma_8c_source.html#l00250">alt_up_pci_sdma_set()</a>, <a class="el" href="alt__up__pci__sdma_8c_source.html#l00229">alt_up_pci_sdma_swreset()</a>, <a class="el" href="alt__up__pci__sdma_8h_source.html#l00032">sdma::bus_addr</a>, <a class="el" href="alt__up__pci__sdma_8h_source.html#l00025">sdma::data_width_in_bytes</a>, <a class="el" href="alt__up__pci__dma_8h_source.html#l00056">alt_up_dma_ctrller::dma_ctrl_base_addr</a>, <a class="el" href="alt__up__pci__sdma_8h_source.html#l00027">sdma::dma_data_bit_mask</a>, <a class="el" href="alt__up__pci__dma_8h_source.html#l00064">alt_up_dma_ctrller::dma_queue</a>, <a class="el" href="alt__up__pci__dma_8h_source.html#l00039">alt_up_pci_dma::dma_rw_slave_addr</a>, <a class="el" href="alt__up__pci__dma_8h_source.html#l00041">alt_up_pci_dma::length</a>, <a class="el" href="alt__up__pci__dma_8h_source.html#l00080">alt_up_dma_ctrller::private_data</a>, <a class="el" href="alt__up__pci__dma_8h_source.html#l00066">alt_up_dma_ctrller::queue_end</a>, <a class="el" href="alt__up__pci__sdma_8h_source.html#l00017">SDMA_BUF_SIZE</a>, <a class="el" href="alt__up__pci__dma_8h_source.html#l00043">alt_up_pci_dma::to_device</a>, <a class="el" href="alt__up__pci__dma_8h_source.html#l00037">alt_up_pci_dma::user_buffer_addr</a>, and <a class="el" href="alt__up__pci__sdma_8h_source.html#l00030">sdma::virt_addr</a>.</p>

<p>Referenced by <a class="el" href="alt__up__pci__driver_8c_source.html#l00466">alt_up_pci_ioctl()</a>.</p>

</div>
</div>
<a class="anchor" id="ad642a47cbcaf420c34ae6d0d7f955992"></a><!-- doxytag: member="alt_up_pci_sdma.c::alt_up_pci_sdma_init" ref="ad642a47cbcaf420c34ae6d0d7f955992" args="(struct alt_up_dma_ctrller *myctrller, int transfer_data_width)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int alt_up_pci_sdma_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structalt__up__dma__ctrller.html">alt_up_dma_ctrller</a> *&nbsp;</td>
          <td class="paramname"> <em>myctrller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>transfer_data_width</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The function to initialize the DMA controller. </p>
<p>This function allocates buffer for the DMA controller to transfer data, initialize necessary data, and clear the registers for dma controller.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>myctrller</em>&nbsp;</td><td>pointer to struct <a class="el" href="structalt__up__dma__ctrller.html" title="The structure to save information for DMA controller.">alt_up_dma_ctrller</a> which points to the dma controller needed to be initialized </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>transfer_data_width</em>&nbsp;</td><td>data width setting for the dma controller</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0 on success, -1 otherwise </dd></dl>

<p>Definition at line <a class="el" href="alt__up__pci__sdma_8c_source.html#l00039">39</a> of file <a class="el" href="alt__up__pci__sdma_8c_source.html">alt_up_pci_sdma.c</a>.</p>

<p>References <a class="el" href="alt__up__pci__sdma_8c_source.html#l00268">alt_up_pci_sdma_clear()</a>, <a class="el" href="alt__up__pci__sdma_8h_source.html#l00032">sdma::bus_addr</a>, <a class="el" href="alt__up__pci__sdma_8h_source.html#l00025">sdma::data_width_in_bytes</a>, <a class="el" href="alt__up__pci__sdma_8h_source.html#l00027">sdma::dma_data_bit_mask</a>, <a class="el" href="alt__up__pci__dma_8h_source.html#l00050">alt_up_dma_ctrller::id</a>, <a class="el" href="alt__up__pci__dma_8h_source.html#l00078">alt_up_dma_ctrller::pci_dev</a>, <a class="el" href="alt__up__pci__dma_8h_source.html#l00080">alt_up_dma_ctrller::private_data</a>, <a class="el" href="alt__up__pci__sdma_8h_source.html#l00017">SDMA_BUF_SIZE</a>, and <a class="el" href="alt__up__pci__sdma_8h_source.html#l00030">sdma::virt_addr</a>.</p>

<p>Referenced by <a class="el" href="alt__up__pci__driver_8c_source.html#l00573">alt_up_pci_dev_init()</a>.</p>

</div>
</div>
<a class="anchor" id="ad1a28dba9f715da7a243f985699e72fe"></a><!-- doxytag: member="alt_up_pci_sdma.c::alt_up_pci_sdma_interrupt" ref="ad1a28dba9f715da7a243f985699e72fe" args="(struct alt_up_dma_ctrller *myctrller)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int alt_up_pci_sdma_interrupt </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structalt__up__dma__ctrller.html">alt_up_dma_ctrller</a> *&nbsp;</td>
          <td class="paramname"> <em>myctrller</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The function to use interrupt. </p>
<p>This function implements interrupt method to check whether the DMA transfer finish. It will go to sleep until the interrupt handler wake up the process.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>myctrller</em>&nbsp;</td><td>The DMA controller selected </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="alt__up__pci__sdma_8c_source.html#l00305">305</a> of file <a class="el" href="alt__up__pci__sdma_8c_source.html">alt_up_pci_sdma.c</a>.</p>

<p>References <a class="el" href="alt__up__pci__dma_8h_source.html#l00072">alt_up_dma_ctrller::condition</a>, <a class="el" href="alt__up__pci__dma_8h_source.html#l00074">alt_up_dma_ctrller::irq</a>, and <a class="el" href="alt__up__pci__dma_8h_source.html#l00070">alt_up_dma_ctrller::wait_queue</a>.</p>

<p>Referenced by <a class="el" href="alt__up__pci__sdma_8c_source.html#l00106">alt_up_pci_sdma_go()</a>.</p>

</div>
</div>
<a class="anchor" id="a267db0a53da4a3f01941940713a25a15"></a><!-- doxytag: member="alt_up_pci_sdma.c::alt_up_pci_sdma_polling" ref="a267db0a53da4a3f01941940713a25a15" args="(struct alt_up_dma_ctrller *myctrller)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int alt_up_pci_sdma_polling </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structalt__up__dma__ctrller.html">alt_up_dma_ctrller</a> *&nbsp;</td>
          <td class="paramname"> <em>myctrller</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The function to poll the result. </p>
<p>This function implements polling method to check whether the DMA transfer finish. It will keep polling the DONE bit of the status register of DMA controller.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>myctrller</em>&nbsp;</td><td>The DMA controller selected </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="alt__up__pci__sdma_8c_source.html#l00281">281</a> of file <a class="el" href="alt__up__pci__sdma_8c_source.html">alt_up_pci_sdma.c</a>.</p>

<p>References <a class="el" href="alt__up__pci__dma_8h_source.html#l00056">alt_up_dma_ctrller::dma_ctrl_base_addr</a>, and <a class="el" href="alt__up__pci__sdma_8h_source.html#l00019">SDMA_POLLING_TIME_OUT_CYCLES</a>.</p>

<p>Referenced by <a class="el" href="alt__up__pci__sdma_8c_source.html#l00106">alt_up_pci_sdma_go()</a>.</p>

</div>
</div>
<a class="anchor" id="a35e0a49125b0d6417e5718a304ad5f5e"></a><!-- doxytag: member="alt_up_pci_sdma.c::alt_up_pci_sdma_set" ref="a35e0a49125b0d6417e5718a304ad5f5e" args="(struct alt_up_dma_ctrller *myctrller, u32 local_addr, u32 phys_addr, u32 length, int to_device)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void alt_up_pci_sdma_set </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structalt__up__dma__ctrller.html">alt_up_dma_ctrller</a> *&nbsp;</td>
          <td class="paramname"> <em>myctrller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>local_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>phys_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>to_device</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The function to set the DMA controller. </p>
<p>The function will write to the control register of DMA controller. It is important that you should add the pcie_tx_base_addr to the phys_addr to make sure the PCIe IP core works correctly.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>myctrller</em>&nbsp;</td><td>The DMA controller selected </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>phys_addr</em>&nbsp;</td><td>The physical address of the kernel buffer </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>local_addr</em>&nbsp;</td><td>The avalon master address you want the DMA controller read from/write to </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>Length of data to transfer in bytes </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>to_device</em>&nbsp;</td><td>if 1, transfer from PC to device; if 0, from device to PC</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The dynamical translation table is not supported yet, you will have to change this function to make the driver support it. </dd></dl>

<p>Definition at line <a class="el" href="alt__up__pci__sdma_8c_source.html#l00250">250</a> of file <a class="el" href="alt__up__pci__sdma_8c_source.html">alt_up_pci_sdma.c</a>.</p>

<p>References <a class="el" href="alt__up__pci__dma_8h_source.html#l00056">alt_up_dma_ctrller::dma_ctrl_base_addr</a>, and <a class="el" href="alt__up__pci__dma_8h_source.html#l00060">alt_up_dma_ctrller::pcie_tx_base_addr</a>.</p>

<p>Referenced by <a class="el" href="alt__up__pci__sdma_8c_source.html#l00106">alt_up_pci_sdma_go()</a>.</p>

</div>
</div>
<a class="anchor" id="af220e3fdd4b481e29010525dfe5d8583"></a><!-- doxytag: member="alt_up_pci_sdma.c::alt_up_pci_sdma_swreset" ref="af220e3fdd4b481e29010525dfe5d8583" args="(struct alt_up_dma_ctrller *myctrller)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alt_up_pci_sdma_swreset </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structalt__up__dma__ctrller.html">alt_up_dma_ctrller</a> *&nbsp;</td>
          <td class="paramname"> <em>myctrller</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The function to do the software reset. </p>
<p>This function will software reset the DMA controller. You should use this function when the DMA transfer is stall, and no other method can be used.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>myctrller</em>&nbsp;</td><td>The DMA controller selected </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="alt__up__pci__sdma_8c_source.html#l00229">229</a> of file <a class="el" href="alt__up__pci__sdma_8c_source.html">alt_up_pci_sdma.c</a>.</p>

<p>References <a class="el" href="alt__up__pci__dma_8h_source.html#l00056">alt_up_dma_ctrller::dma_ctrl_base_addr</a>.</p>

<p>Referenced by <a class="el" href="alt__up__pci__sdma_8c_source.html#l00106">alt_up_pci_sdma_go()</a>.</p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Nov 2 2011 15:00:38 for alt_up_driver_codes by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
